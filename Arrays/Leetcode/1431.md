
---

# ğŸ“Œ Kids With the Greatest Number of Candies

## ğŸ“ Problem Statement
Given an array `candies` representing the number of candies each kid has, and an integer `extraCandies`, determine if each kid can have the greatest number of candies after receiving the extra candies.

Return a boolean array where for each kid, the result is `true` if they can have the greatest number of candies (or tie for greatest) after receiving the extra candies, and `false` otherwise.

### ğŸ“ Example:
```javascript
Input: candies = [2,3,5,1,3], extraCandies = 3
Output: [true,true,true,false,true]
Explanation: 
- Kid with 5 candies will always have the most (even if others receive extras)
- After giving extra candies: [5,6,8,4,6]
- Comparison with original maximum (5): [5â‰¥5, 6â‰¥5, 8â‰¥5, 4â‰¥5, 6â‰¥5]
```

---

## ğŸ”„ Approach (Two-Pass Comparison)
1. **Find Maximum**: First determine the current maximum number of candies any kid has.
2. **Evaluate Potential**: Then check if each kid's candies plus extra would meet or exceed this maximum.

### ğŸ”¥ Steps:
- Initialize `mostCandies` to track the current maximum
- Create a result array of booleans
- First pass: Find the maximum value in `candies`
- Second pass: Compare each kid's potential (candies + extra) with `mostCandies`

---

## ğŸ’» Code Implementation:
```go
func kidsWithCandies(candies []int, extraCandies int) []bool {
    mostCandies := 0
    result := make([]bool, len(candies))

    // Find the maximum number of candies
    for _, num := range candies {
        if num > mostCandies {
            mostCandies = num
        }
    }

    // Check each kid's potential
    for idx, num := range candies {
        result[idx] = num + extraCandies >= mostCandies
    }

    return result
}
```

---

## ğŸ“Š Complexity Analysis:
- **Time Complexity:** `O(N)` â†’ Two linear passes through the array
- **Space Complexity:** `O(N)` â†’ Output array storage (required by problem)

---

## ğŸ Dry Run:
### ğŸ”¹ Input:
```javascript
candies = [4,2,1,4,3], extraCandies = 2
```
### ğŸ”¹ Execution:

1. **Find Maximum**:
   - Iterate through [4,2,1,4,3] â†’ `mostCandies = 4`

2. **Evaluate Potential**:
   - [4+2â‰¥4, 2+2â‰¥4, 1+2â‰¥4, 4+2â‰¥4, 3+2â‰¥4]
   - â†’ [6â‰¥4, 4â‰¥4, 3â‰¥4, 6â‰¥4, 5â‰¥4]
   - â†’ [true, true, false, true, true]

### ğŸ”¹ Output:
```javascript
[true,true,false,true,true]
```

---

## âœ… Edge Cases Considered:
- **All kids can be greatest**: `[1,1,1]`, extra=1 â†’ `[true,true,true]`
- **Single kid**: `[5]`, extra=3 â†’ `[true]`
- **Negative extra candies**: Handled naturally by comparison
- **Multiple maximums**: Preserves all maximum positions

---

## ğŸ¯ Summary:
- **Efficient two-pass solution** with clear logic âœ…
- **Handles all edge cases** including ties and minimum inputs âœ…
- **Optimal O(N) time complexity** âœ…

ğŸš€ *Great example of simple array transformation!* ğŸš€

---
