
---

# ğŸ“Œ Number of Good Pairs

## ğŸ“ Problem Statement
Given an array of integers `nums`, return the number of **good pairs**.  
A pair `(i, j)` is called *good* if `nums[i] == nums[j]` and `i < j`.

### ğŸ“ Example:
```javascript
Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: 
There are 4 good pairs:
- (0,3), (0,4), (3,4), (2,5)
```

---

## ğŸ”„ Approach (Frequency Counting)
We efficiently count good pairs using a hash map to track occurrences of each number.

### ğŸ”¥ Key Insight:
Each new occurrence of a number can form a pair with all previous occurrences of that same number.

### Steps:
1. Initialize a counter `count` and a frequency map `freq`
2. For each number in `nums`:
   - Add the current frequency of that number to `count` (forms new pairs with all previous occurrences)
   - Increment the number's frequency in the map
3. Return the total count

---

## ğŸ’» Code Implementation:
```go
func numIdenticalPairs(nums []int) int {
    count := 0
    freq := make(map[int]int)

    for _, num := range nums {
        count += freq[num] // Add existing occurrences
        freq[num]++        // Update frequency
    }

    return count
}
```

---

## ğŸ“Š Complexity Analysis:
- **Time Complexity:** O(N) - Single pass through the array
- **Space Complexity:** O(N) - Storage for frequency map in worst case (all unique elements)

---

## ğŸ Dry Run:
### ğŸ”¹ Input:
```javascript
nums = [1,1,2,1,2,2]
```

### ğŸ”¹ Execution:
| Number | Frequency Before | Pairs Added | Frequency After |
|--------|------------------|-------------|------------------|
| 1      | 0                | 0           | 1                |
| 1      | 1                | 1           | 2                |
| 2      | 0                | 0           | 1                |
| 1      | 2                | 2           | 3                |
| 2      | 1                | 1           | 2                |
| 2      | 2                | 2           | 3                |

**Total Pairs:** 0 + 1 + 0 + 2 + 1 + 2 = 6

### ğŸ”¹ Output:
```javascript
6
```

---

## âœ… Edge Cases Considered:
- **No pairs**: `[1,2,3]` â†’ 0
- **All identical**: `[5,5,5]` â†’ 3
- **Single element**: `[7]` â†’ 0
- **Large numbers**: Handled by map implementation

---

## ğŸ¯ Why This Solution Rocks:
- **Optimal O(N) time** - Beats brute-force O(NÂ²) approach
- **Elegant frequency counting** - No nested loops needed
- **Clear mathematical logic** - Each new occurrence creates n-1 new pairs

ğŸš€ *Perfect example of using hash maps for efficient counting!* ğŸš€

---
