
---

# ğŸ“Œ Jewels and Stones

## ğŸ“ Problem Statement
Given two strings `jewels` and `stones`, return how many of the `stones` are also `jewels`.  
Each character in `stones` represents a stone, and each character in `jewels` represents a jewel.  
The comparison is case-sensitive ("a" â‰  "A").

### ğŸ“ Example:
```javascript
Input: jewels = "aA", stones = "aAAbbbb"
Output: 3
Explanation: 
There are 3 jewels in stones:
- 'a' appears once
- 'A' appears twice
```

---

## ğŸ”„ Approach (Hash Set Lookup)
We use a hash set to store jewels for O(1) lookups when checking stones.

### ğŸ”¥ Key Insight:
- Convert jewels to a set for instant membership testing
- Count how many stones exist in this jewel set

### Steps:
1. Create a hash set from `jewels` characters
2. Iterate through `stones` and count matches
3. Return the total count

---

## ğŸ’» Code Implementation:
```go
func numJewelsInStones(jewels string, stones string) int {
    jewelsMap := make(map[rune]struct{})
    count := 0

    // Build jewel lookup set
    for _, jewel := range jewels {
        jewelsMap[jewel] = struct{}{}
    }

    // Count matching stones
    for _, stone := range stones {
        if _, isJewel := jewelsMap[stone]; isJewel {
            count++
        }
    }

    return count
}
```

---

## ğŸ“Š Complexity Analysis:
- **Time Complexity:** O(M + N)  
  (M = length of jewels, N = length of stones)
- **Space Complexity:** O(M)  
  (Storage for jewel set)

---

## ğŸ Dry Run:
### ğŸ”¹ Input:
```javascript
jewels = "zZ", stones = "zzZZz"
```

### ğŸ”¹ Execution:
1. Jewel Set: {'z', 'Z'}
2. Stone Check:
   - 'z' â†’ match (count=1)
   - 'z' â†’ match (count=2)
   - 'Z' â†’ match (count=3)
   - 'Z' â†’ match (count=4)
   - 'z' â†’ match (count=5)

### ğŸ”¹ Output:
```javascript
5
```

---

## âœ… Edge Cases Considered:
- **No matches**: jewels="a", stones="BBB" â†’ 0
- **All matches**: jewels="abc", stones="cccbba" â†’ 6
- **Empty jewels**: jewels="", stones="abc" â†’ 0
- **Empty stones**: jewels="a", stones="" â†’ 0
- **Case sensitivity**: jewels="A", stones="a" â†’ 0

---

## ğŸ¯ Why This Solution Rocks:
- **Optimal O(M+N) time** - Beats O(M*N) brute-force
- **Clean set-based logic** - Easy to understand
- **Memory efficient** - Only stores unique jewels
- **Handles Unicode** - Uses `rune` for full character support

ğŸš€ *Perfect example of set theory in string processing!* ğŸš€

---
