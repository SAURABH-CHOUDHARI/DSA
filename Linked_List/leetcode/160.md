# ğŸš€ Find Intersection of Two Linked Lists

## ğŸ“Œ Problem Statement
Given the heads of two **singly linked lists**, determine if they **intersect** at a node. If they do, return the intersection node; otherwise, return `null`.

## ğŸ’¡ Solution Approaches
We have two different approaches to solve this problem:

---

## ğŸ”¹ Approach 1: Using a Hash Set
### ğŸ” Step-by-Step Explanation
1. **ğŸ›‘ Base Case Check**
   - If either list is `null`, return `null` immediately.

2. **ğŸ“¦ Store Nodes in a Set**
   - Traverse `headA` and add all its nodes to a **set**.

3. **ğŸ”„ Traverse `headB` and Check for Intersection**
   - If any node in `headB` exists in the set, return that node.

### ğŸ“ Code Implementation
```javascript
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) return null; // ğŸ›‘ Base Case
    
    let set = new Set();
    
    while (headA != null) { // ğŸ“¦ Store nodes from headA
        set.add(headA);
        headA = headA.next;
    }
    
    while (headB != null) { // ğŸ”„ Check for intersection
        if (set.has(headB)) return headB;
        headB = headB.next;
    }
    
    return null; // âŒ No intersection found
};
```

### â³ Complexity Analysis
- **Time Complexity:** `O(m + n)`, where `m` and `n` are the lengths of the two lists.
- **Space Complexity:** `O(m)`, due to the extra set storing `headA` nodes.

---

## ğŸ”¹ Approach 2: Two Pointers (Optimized)
### ğŸ” Step-by-Step Explanation
1. **ğŸ›‘ Base Case Check**
   - If either list is `null`, return `null`.

2. **ğŸ”„ Traverse Using Two Pointers**
   - Start `t1` at `headA` and `t2` at `headB`.
   - Move both pointers forward one step at a time.
   - When a pointer reaches `null`, redirect it to the head of the other list.

3. **ğŸ” Repeat Until They Meet**
   - The pointers will meet at the **intersection** node if there is one.
   - If no intersection exists, they will both reach `null` at the same time.

### ğŸ“ Code Implementation
```javascript
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) return null; // ğŸ›‘ Base Case
    
    let t1 = headA, t2 = headB;
    
    while (t1 !== t2) { // ğŸ”„ Traverse both lists
        t1 = t1.next;
        t2 = t2.next;
        
        if (t1 === t2) return t1; // ğŸ¯ Found intersection
        
        if (t1 === null) t1 = headB; // ğŸ”€ Switch to other list
        if (t2 === null) t2 = headA; // ğŸ”€ Switch to other list
    }
    
    return t1; // âœ… Return intersection node or null
};
```

### â³ Complexity Analysis
- **Time Complexity:** `O(m + n)`, since both pointers traverse both lists once.
- **Space Complexity:** `O(1)`, as no extra data structures are used.

---

## ğŸ”¥ Example Walkthrough

### **Input:**
```plaintext
List A: 4 -> 1 -> 8 -> 4 -> 5
List B: 5 -> 6 -> 1 -> 8 -> 4 -> 5
Intersection at node with value: 8
```

### **Processing:**
#### Approach 1 (Hash Set Method):
1ï¸âƒ£ Store nodes of List A in a **set**.
2ï¸âƒ£ Traverse List B and **find the first node** present in the set (`8`).

#### Approach 2 (Two Pointers Method):
1ï¸âƒ£ `t1` starts at `4`, `t2` starts at `5`.
2ï¸âƒ£ Both move one step at a time.
3ï¸âƒ£ When `t1` reaches `null`, switch to `headB`.
4ï¸âƒ£ When `t2` reaches `null`, switch to `headA`.
5ï¸âƒ£ Eventually, both pointers meet at **node `8`**.

### **Output:**
```plaintext
8
```

---

## ğŸ¯ Key Takeaways
âœ… **First approach** (hash set) is simple but uses extra space.
âœ… **Second approach** (two-pointer method) is more optimized (`O(1)` space).
âœ… Both approaches run in **O(m + n) time complexity**.

Happy Coding! ğŸš€ğŸ‰

