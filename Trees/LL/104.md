# Maximum Depth of a Binary Tree

## ğŸŒ³ Problem Statement
Given the **root** of a binary tree, return its **maximum depth**.

The **maximum depth** of a binary tree is the number of nodes along the longest path from the root node **down to the farthest leaf node**.

---

## ğŸ¯ Intuition
A binary tree consists of nodes connected in a hierarchical manner. To determine its depth:
- We start from the **root** and explore both left and right subtrees.
- The depth of a node is the **maximum depth** of its left and right subtrees, plus **1** for the current node.
- If a node is `null`, it contributes a depth of `0`.

---

## ğŸš€ Approach

### ğŸ”¹ Fundamental Concept: **Recursion**
We use a **recursive approach** to solve this problem:
1. If the **root is null**, return `0` (base case).
2. Recursively find the **depth of the left subtree**.
3. Recursively find the **depth of the right subtree**.
4. The depth of the current node is `1 + max(leftDepth, rightDepth)`.

---

## ğŸ§‘â€ğŸ’» Code Implementation

```javascript
var maxDepth = function (root) {
    if (!root) return 0;
    let left = maxDepth(root.left);
    let right = maxDepth(root.right);
    return Math.max(left, right) + 1;
};
```

---

## ğŸ“œ Dry Run Example

### Example 1

**Input:**
```
    3
   / \
  9   20
     /  \
    15   7
```

**Function Calls:**
```
maxDepth(3) â†’ maxDepth(9) â†’ returns 1
             maxDepth(20) â†’ maxDepth(15) â†’ returns 1
                           maxDepth(7) â†’ returns 1
             maxDepth(20) â†’ returns max(1,1) + 1 = 2
maxDepth(3) â†’ returns max(1,2) + 1 = 3
```

**Output:** `3`

### Example 2

**Input:**
```
   1
    \
     2
      \
       3
```

**Output:** `3`

---

## â³ Complexity Analysis
- **Time Complexity:** `O(N)`, since we visit each node exactly once.
- **Space Complexity:** `O(H)`, where `H` is the height of the tree (worst-case `O(N)` for a skewed tree, best-case `O(log N)` for a balanced tree).

---

## ğŸ” Edge Cases Considered
âœ… **Empty Tree (`root = null`)** â†’ Returns `0`
âœ… **Single Node Tree (`root` without children)** â†’ Returns `1`
âœ… **Unbalanced Trees** â†’ Handles trees with nodes only on one side

---

## ğŸ¯ Summary
- Used **recursion** to determine the maximum depth.
- Traversed each node once â†’ `O(N)` time complexity.
- Efficient approach leveraging **divide and conquer**.

ğŸ”¥ **Happy Coding!** ğŸš€

