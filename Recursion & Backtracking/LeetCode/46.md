
# Permutations Generator ğŸ“âœ¨

This JavaScript code generates all possible permutations of an input array using a backtracking approach. Letâ€™s break it down step-by-step with intuition, a dry run, and the code itself! ğŸŒŸ

## Problem Statement â“
Given an array of distinct numbers `nums`, return all possible permutations of the array. For example:  
- **Input**: `[1, 2, 3]`  
- **Output**: `[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]` ğŸ‰

## Intuition ğŸ§ ğŸ’¡
To generate permutations, we need to:  
1. Use each number in the array exactly once in every possible position.  
2. Avoid repetition by tracking which numbers weâ€™ve used.  
3. Build permutations step-by-step and backtrack when needed.  

We use a recursive backtracking algorithm:  
- Pick a number, add it to the current permutation. âœ…  
- Mark it as "visited" to avoid reuse in the same permutation. ğŸš«  
- Recursively build the rest of the permutation. ğŸ”„  
- Backtrack by removing the number and unmarking it to try other options. âª  

## Step-by-Step Approach ğŸš¶â€â™‚ï¸
1. **Initialize Variables** âš™ï¸:  
   - `ans`: Array to store all permutations.  
   - `cur`: Temporary array to build the current permutation.  
   - `isVis`: Boolean array to track used numbers (visited).  

2. **Recursive Function (`solve`)** ğŸ”§:  
   - **Base Case**: If the current permutation length equals the input array length, add it to `ans`. ğŸ  
   - Loop through all numbers:  
     - If a number isnâ€™t visited, add it to `cur`. â•  
     - Mark it as visited. âœ”ï¸  
     - Recurse to build the next position. ğŸŒ±  
     - Backtrack: Remove the number from `cur` and unmark it. â¬…ï¸  

3. **Main Function (`permute`)** ğŸ¬:  
   - Set up the initial state and call `solve`.  

## Dry Run ğŸƒâ€â™‚ï¸ğŸ’¨
Letâ€™s dry run with `nums = [1, 2]`:  

### Initial State:
- `ans = []`  
- `cur = []`  
- `isVis = [false, false]`  
- `i = 0`  

### Step 1: Start with `i = 0`
- Loop `j = 0`: `nums[0] = 1`  
  - `cur = [1]`, `isVis = [true, false]`  
  - Recurse with `i = 1`  
    - Loop `j = 1`: `nums[1] = 2`  
      - `cur = [1, 2]`, `isVis = [true, true]`  
      - `i = 2` (equals `nums.length`), add `[1, 2]` to `ans` ğŸ¯  
    - Backtrack: `cur = [1]`, `isVis = [true, false]`  
  - Backtrack: `cur = []`, `isVis = [false, false]`  

- Loop `j = 1`: `nums[1] = 2`  
  - `cur = [2]`, `isVis = [false, true]`  
  - Recurse with `i = 1`  
    - Loop `j = 0`: `nums[0] = 1`  
      - `cur = [2, 1]`, `isVis = [true, true]`  
      - `i = 2`, add `[2, 1]` to `ans` ğŸ¯  
    - Backtrack: `cur = [2]`, `isVis = [false, true]`  
  - Backtrack: `cur = []`, `isVis = [false, false]`  

### Final Output:
- `ans = [[1, 2], [2, 1]]` ğŸ‰  

## Code Snippet ğŸ’»ğŸ› ï¸
Hereâ€™s the full code:

```javascript
var solve = function(nums, ans, cur, isVis, i) {
    if (i == nums.length) {
        ans.push([...cur]);  // Spread to create a new array
        return;
    }
    for (let j = 0; j < nums.length; j++) {
        if (!isVis[j]) {
            cur.push(nums[j]);       // Add number to current permutation
            isVis[j] = true;         // Mark as visited
            solve(nums, ans, cur, isVis, i + 1);  // Recurse
            cur.pop();               // Backtrack: remove last number
            isVis[j] = false;        // Unmark
        }
    }
};

var permute = function(nums) {
    let ans = [];                 // Store all permutations
    let cur = [];                 // Build current permutation
    let isVis = new Array(nums.length).fill(false);  // Visited array
    solve(nums, ans, cur, isVis, 0);  // Start recursion
    return ans;
};
```


# Time & Space Complexity â±ï¸ğŸ“Š
## Time Complexity: O(n!) â³  
We generate all n! permutations, where n is the length of the input array.
## Space Complexity: O(n) + O(n * n!) ğŸ—ƒï¸  
O(n) for the recursion stack and isVis array.  
O(n * n!) to store all permutations in the output.
# Conclusion ğŸŒŸğŸ‰
This backtracking solution efficiently generates all permutations by exploring every possibility and undoing steps when needed. Itâ€™s a classic example of recursion and backtracking in action! Try it with different arrays and watch the magic unfold! âœ¨ Happy coding! ğŸ˜ŠğŸš€

