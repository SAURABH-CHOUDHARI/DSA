# ğŸŒ³ Same Tree Problem

## ğŸ“Œ Problem Statement
Given the roots of two binary trees `p` and `q`, determine if they are **identical** or not. Two binary trees are considered **identical** if they have the same structure and node values.

---

## ğŸš€ Approach

### ğŸ”¹ Recursive Approach
We use **recursion** to compare both trees simultaneously:
1. **Base Case:**
   - If both `p` and `q` are `null`, return `true` (both trees are empty and thus identical).
   - If one of them is `null` while the other is not, return `false` (structures are different).

2. **Recursive Case:**
   - Check if `p.val` is equal to `q.val`.
   - Recursively compare the **left** subtree of both trees.
   - Recursively compare the **right** subtree of both trees.
   - If both subtrees are identical, return `true`, otherwise return `false`.

---

## ğŸ§‘â€ğŸ’» Code Implementation

```javascript
var isSameTree = function(p, q) {
    if (!p && !q) return true;
    if ((!p && q) || (p && !q)) return false;
    if (p.val == q.val) {
        let left = isSameTree(p.left, q.left);
        let right = isSameTree(p.right, q.right);
        return left && right;
    }
    return false;
};
```

---

## ğŸ“ Dry Run

### Example 1:
#### Input:
```
p = [1,2,3]
q = [1,2,3]
```
#### Visual Representation:
```
   p       q
   1       1
  / \     / \
 2   3   2   3
```
#### Execution Steps:
- Both trees have `1` as root â†’ check left and right.
- Left subtree: `2 == 2`, recursively check children (both `null`). âœ…
- Right subtree: `3 == 3`, recursively check children (both `null`). âœ…
- Return `true`.

### Example 2:
#### Input:
```
p = [1,2]
q = [1,null,2]
```
#### Visual Representation:
```
   p       q
   1       1
  /       \
 2         2
```
#### Execution Steps:
- `1 == 1` â†’ check left and right.
- Left subtree: `p.left = 2`, `q.left = null` âŒ â†’ Return `false`.

#### Output: `false`

---

## â³ Complexity Analysis
- **Time Complexity:** `O(N)`, where `N` is the number of nodes (each node is visited once).
- **Space Complexity:** `O(H)`, where `H` is the height of the tree (for recursive stack space).
  - Worst case (skewed tree): `O(N)`.
  - Best case (balanced tree): `O(log N)`.

---

## ğŸ” Edge Cases
âœ… Both trees are empty (`null`).
âœ… Trees have the same values but different structures.
âœ… Trees have different values at some nodes.
âœ… Trees are large and unbalanced (deep recursion depth).

---

## ğŸ¯ Summary
- Used **recursion** to check each node.
- Compared **values** and **structures** simultaneously.
- Handled **edge cases** for different tree shapes and sizes.

ğŸš€ **Happy Coding!** ğŸŒ²

