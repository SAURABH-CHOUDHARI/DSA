# 🌳 Construct Binary Tree from Preorder and Inorder Traversal

## 💡 Intuition
To reconstruct a binary tree, we can take advantage of the **preorder** and **inorder** traversal properties:
- Preorder gives us the **root node first**.
- Inorder helps us determine the **left and right subtrees** based on the root’s position.

By combining these two traversal sequences, we can recursively rebuild the binary tree.

---

## 🚀 Approach
1. **Preorder Traversal** always starts with the root node.
2. **Inorder Traversal** allows us to split the array into left and right subtrees based on the root.
3. Use a **map** to quickly locate the index of any element in the inorder traversal.
4. Recursively build the tree using preorder and inorder arrays.

---

## 🧩 Steps
1. Create a hashmap of value -> index for inorder traversal.
2. Define a recursive helper function `solve()` that uses indices to avoid slicing arrays.
3. For each call:
   - Create root node using current `preStart`.
   - Find the root index in the inorder array.
   - Recursively build left and right subtrees.
4. Return the constructed root node.

---

## 🧑‍💻 Code
```javascript
var buildTree = function(preorder, inorder) {
    let solve = (preorder, preStart, preEnd, inorder, inStart, inEnd, mp) => {
        if (preStart > preEnd || inStart > inEnd) return null;

        let root = new TreeNode(preorder[preStart]);
        let inRootIndex = mp.get(preorder[preStart]);
        let numsLeft = inRootIndex - inStart;

        root.left = solve(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRootIndex - 1, mp);
        root.right = solve(preorder, preStart + numsLeft + 1, preEnd, inorder, inRootIndex + 1, inEnd, mp);

        return root;
    }

    let mp = new Map();
    for (let i = 0; i < inorder.length; i++) {
        mp.set(inorder[i], i);
    }

    return solve(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, mp);
};
```

---

## 🔍 Dry Run Example
### Input:
```
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```
- Root = 3
- Left subtree from inorder = [9]
- Right subtree from inorder = [15,20,7]

Recursive steps will build the tree:
```
    3
   / \
  9  20
     / \
    15  7
```
✅ Tree is correctly constructed.

---

## ⏱️ Complexity
- **Time Complexity:** `O(n)` where `n` is the number of nodes. Each node is visited once.
- **Space Complexity:** `O(n)` for the hashmap and recursion stack.

---

## 🧠 Summary
- Efficient reconstruction using traversal properties.
- Avoids repeated slicing with index boundaries.
- Hashmap optimizes lookup from `O(n)` to `O(1)`.

Perfect for tree reconstruction problems with traversal arrays. 🌳✅

